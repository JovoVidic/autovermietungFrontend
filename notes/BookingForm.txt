
import { useState, useEffect } from 'react';
import { calculatePrice, rentAuto } from '../api/calculatePrice';
import type { PriceRequestDto } from '../api/types';
import { validateBookingForm, isBookingFormValid } from './validation';

type Props = {
  autoId: number;
  onBooked: (preis: number) => void;
};

const DEFAULT_CUSTOMER_ID = 1 as const;

// --- Hilfstyp für die UI-Fehlerbox ---
type ErrorBoxData = {
  title: string;
  message: string;
  details: Record<string, any> | null;
};

// --- Utility: rohen Fehler (oder Error-Objekt) schön aufbereiten ---
// Falls rentAuto strukturierte Errors wirft (message + details), greift der erste Zweig.
// Andernfalls wird dein bisheriges "HTTP 409 — {...}"-Muster geparst.
function formatServerError(raw: unknown): ErrorBoxData {
  const fallback: ErrorBoxData = {
    title: 'Buchung nicht möglich',
    message: 'Die Buchung konnte nicht durchgeführt werden.',
    details: null,
  };

  // 1) Error-Objekt mit message (+ optional details vom Backend via rentAuto)
  if (raw && typeof raw === 'object') {
    const obj = raw as any;
    if (obj.message) {
      const details =
        obj.details && typeof obj.details === 'object' ? obj.details : null;
      return {
        title: 'Buchung nicht möglich',
        message: String(obj.message),
        details,
      };
    }
  }

  // 2) Versuch: Text analysieren und JSON-Teil extrahieren
  const text = String((raw as any)?.toString?.() ?? '');
  if (!text) return fallback;

  // Dein Muster: "HTTP 409 Conflict — {...json...}"
  const parts = text.split('—');
  let json: any = null;

  if (parts.length > 1) {
    try {
      json = JSON.parse(parts[1].trim());
    } catch {
      // kein JSON, ignorieren
    }
  } else {
    try {
      json = JSON.parse(text.trim());
    } catch {
      // kein JSON, ignorieren
    }
  }

  if (json && typeof json === 'object') {
    const message = json.message ?? json.error ?? fallback.message;
    const details: Record<string, any> = {};
    if (json.vermietetVon) details['Vermietet von'] = json.vermietetVon;
    if (json.vermietetBis) details['Vermietet bis'] = json.vermietetBis;
    if (json.freiAb) details['Wieder frei ab'] = json.freiAb;

    return {
      title: 'Buchung nicht möglich',
      message: String(message),
      details: Object.keys(details).length ? details : null,
    };
  }

  // 3) Fallback: HTTP-Text freundlich umformulieren
  if (/HTTP\s+\d+/.test(text)) {
    return {
      title: 'Buchung nicht möglich',
      message: 'Dieses Auto ist im gewählten Zeitraum bereits vermietet.',
      details: null,
    };
  }

  return fallback;
}

export default function BookingForm({ autoId, onBooked }: Props) {
  const [startDatum, setStartDatum] = useState('');
  const [endDatum, setEndDatum] = useState('');
  const [insuranceOption, setInsuranceOption] = useState<'TEILKASKO' | 'VOLLKASKO' | ''>('');
  const [preis, setPreis] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);

  // **Neu**: freundliche Fehlerbox (ersetzt den alten string `err`)
  const [errorBox, setErrorBox] = useState<ErrorBoxData | null>(null);

  // Preis live berechnen, wenn alle Daten vorhanden sind
  useEffect(() => {
    // Bei Eingaben: alte Fehlerbox schließen
    setErrorBox(null);

    if (!startDatum || !endDatum || !insuranceOption) {
      setPreis(null);
      return;
    }

    const req: PriceRequestDto = {
      autoId,
      startDate: startDatum,
      endDate: endDatum,
      insuranceOption: insuranceOption as 'TEILKASKO' | 'VOLLKASKO',
    };

    let active = true;
    // Optional: leichter Debounce, damit nicht bei jedem Tastendruck gefeuert wird
    const t = setTimeout(() => {
      calculatePrice(req)
        .then((p) => active && setPreis(p))
        .catch(() => active && setPreis(null));
    }, 150);

    return () => {
      active = false;
      clearTimeout(t);
    };
  }, [startDatum, endDatum, insuranceOption, autoId]);

  const submit = async (e: React.FormEvent) => {
    e.preventDefault();
    setErrorBox(null);

    const errorMsg = validateBookingForm(startDatum, endDatum, insuranceOption);
    if (errorMsg) {
      setErrorBox({
        title: 'Buchung nicht möglich',
        message: errorMsg,
        details: null,
      });
      return;
    }

    try {
      setLoading(true);
      const payload = {
        autoId,
        customerId: DEFAULT_CUSTOMER_ID,
        startDatum,
        endDatum,
        insuranceOption: insuranceOption || undefined,
      };
      const finalPrice = await rentAuto(payload);
      setErrorBox(null);
      onBooked(finalPrice);
    } catch (e: any) {
      const formatted = formatServerError(e?.message ?? e);
      setErrorBox(formatted);
    } finally {
      setLoading(false);
    }
  };

  // einfache Inline-Styles (ohne CSS-Framework)
  const alertStyle: React.CSSProperties = {
    marginTop: 12,
    padding: '10px 12px',
    borderRadius: 6,
    border: '1px solid #f5c2c7',
    background: '#f8d7da',
    color: '#58151c',
  };

  const alertTitleStyle: React.CSSProperties = { fontWeight: 600, marginBottom: 4 };
  const alertListStyle: React.CSSProperties = { margin: '6px 0 0 0', paddingLeft: 18 };

  return (
    <form onSubmit={submit} style={{ display: 'grid', gap: 13, maxWidth: 520 }}>
      <div>
        <label>Startdatum</label><br />
        <input type="date" value={startDatum} onChange={e => setStartDatum(e.target.value)} />
      </div>
      <div>
        <label>Enddatum</label><br />
        <input type="date" value={endDatum} onChange={e => setEndDatum(e.target.value)} />
      </div>
      <div>
        <label>Versicherung</label><br />
        <select
          value={insuranceOption}
          onChange={e => setInsuranceOption(e.target.value as 'TEILKASKO' | 'VOLLKASKO' | '')}
        >
          <option value="">(keine Auswahl)</option>
          <option value="TEILKASKO">Teilkasko</option>
          <option value="VOLLKASKO">Vollkasko</option>
        </select>
      </div>

      {preis !== null && <div><strong>Gesamtpreis:</strong> {preis.toFixed(2)} €</div>}

      {/* Freundliche Fehlerbox */}
      {errorBox && (
        <div role="alert" aria-live="assertive" style={alertStyle}>
          <div style={alertTitleStyle}>❗ {errorBox.title}</div>
          <div>{errorBox.message}</div>
          {errorBox.details && (
            <ul style={alertListStyle}>
              {Object.entries(errorBox.details).map(([k, v]) => (
                <li key={k}>
                  <strong>{k}:</strong> {String(v)}
                </li>
              ))}
            </ul>
          )}
        </div>
      )}

      <button
        type="submit"
        disabled={loading || !isBookingFormValid(startDatum, endDatum, insuranceOption)}
      >
        {loading ? 'Buchen…' : 'Buchen'}
      </button>
    </form>
  );
}

